- 서명 키 관리 부실: 가장 치명적인 문제로, 유출된 JWT 서명 키(Secret Key)를 이용해 공격자가 유효한 토큰을 무단으로 생성하거나 탈취된 토큰을 장기간 사용할 수 있습니다.

- ![[Pasted image 20260107101138.png]]
- 베어본즈(최소한의 구성) 상태 관리 솔루션
- 리덕스에서 필요한 거 빼고 다 걷어 낸게 주스턴스(베어본즈)고 보안적으로 더 취약함.
- 그래서 주스턴스를 사용해서 커스텀으로 보안써야함.
- 리덕스가 완성품이어서 보안이 강하다고 생각할 수 있는데, 코드자체도 다 오픈되서 보안이 완벽하지 않음.
- 토큰이 상태
- 훅 = 리액트의 함수 
- flux 비동기
- https://zustand.docs.pmnd.rs/getting-started/introduction 
- 주스턴스의 객체 - 
- Provider : Provider = 공통 자원(데이터·상태·설정·기능)을 하위 영역에 전달하는 공급자
-  ![[Pasted image 20260107104450.png]]
- 주스턴스에서 가장 안쪽의 공간이 store(최상단 부모), 
- 전역에 바로 직통으로 빠지게 하는게 provider
- 리액트(넥스트 js 합쳐진) - provider - 주스턴스()
- 
-  ![[Pasted image 20260107105940.png]]
-  ### 왜 Provider가 필요한가?
#### 1. 클라이언트 전용 앱 (CSR)
- Provider 불필요
- Zustand 스토어가 브라우저 메모리에서 싱글톤으로 동작
- 현재 프로젝트 방식

#### 2. Next.js SSR/SSG 환경에서의 문제

- 서버에서 스토어가 공유됨: Node.js 서버는 여러 사용자 요청을 처리하는데, Provider 없이 전역 스토어를 사용하면 모든 사용자가 같은 스토어 인스턴스를 공유하게 됨
- Hydration 불일치: 서버에서 렌더링된 HTML과 클라이언트의 상태가 달라서 Hydration 에러 발생 가능
- 요청 간 상태 누출: 사용자 A의 인증 토큰이 사용자 B에게 노출될 수 있음 (보안 문제)
---

### 현재 프로젝트가 괜찮은 이유
현재 authStore.ts를 보면:
1. 'use client' 컴포넌트에서만 사용: page.tsx, dashboard/page.tsx 모두 'use client' 선언

2. 서버 컴포넌트에서 사용 안 함: 스토어가 클라이언트에서만 동작

3. 초기값이 null: accessToken: null로 시작하므로 서버/클라이언트 불일치 없음

---
### Provider가 권장되는 경우
- // 예시: Zustand Provider 패턴
- 이 패턴이 필요한 경우:

- 서버 컴포넌트에서 스토어 초기값 주입 필요 시

- 요청별 독립된 스토어 인스턴스 필요 시

- 테스트 환경에서 스토어 격리 필요 시
  
- 리덕스가 아니여도 
- 10월 29일 참조
- 자바 : 변수 속성(프로펄티) 
- SQL(DB) : 컬럼
- 파이썬 : 변수, 피처
- JS : 상태(현업,에서는 변수라고함 )
- ![[Pasted image 20260107111903.png]]
- 일반적으로는 파일만 됨.
- ![[Pasted image 20260107111810.png]]
- 슬라이스, 전체의 맛과 일부의 맛과 같으니까 폴더와 파일이 둘다 허용됨
- ts, tsx의 확장자
- 렌더링이 없으면 ts
- component -> service -> store
- 
- next16 주스턴스에 덕스 패턴을 적용시켜줘
- 컨테이너 : 데이터만 있고 틀만 잇는거
- 바디안에 컴포넌트 코드에서 데이터.
- 컴포넌트 : 
- 변수 : 컴포넌트 조각.
- tsx . return 위 컴포넌트 , `div` 컨테이너가 될 놈.
- tsx : 컴포넌트 + 컨테이너
- ts : 컴포넌트

- 프로바이더의 역할 : 주스턴스와 리액트를 연결하는 객체.
- 값·상태·설정·자원(의존성)을 생성·보관하고, 하위 영역에서 사용할 수 있게 “제공하는 역할”을 하는 객체 또는 구조
- authstore.ts 여기에 zustand, 넥스트 16, 덕스패턴, 프로바이더 구조로 변경하고,
- accesstoken만 저장할 거야. refreshtoken은 httponly 쿠키에 저장할거야. 그래서 여기에는 
- refreshtoken 관련 로직은 추가하지 말아줘.
- store는 auth.store.ts
- 
- main.service 여기에서 로그인 성공하면, accessToken은 auth.store.ts 여기에 저장하고, refreshToken 은 httpOnly 쿠키에 저장하는 코드를 생성해줘.
- 
- 개념 정리
- ![[Pasted image 20260107164559.png]]
- createStore는 Zustand 라이브러리 함수입니다.
- createAuthStore() 팩토리 함수 내부에서 호출됩니다.
- : 팩토리 함수란, 호출될 때마다 “새로운 객체(인스턴스)”를 만들어서 반환하는 함수
- 
- Provider가 하는 일:
1. 스토어 인스턴스 생성: createStore() 호출
2. React Context 제공: 하위 컴포넌트에 스토어 전달
3. SSR 격리: 요청별 독립된 스토어 인스턴스 보장
- ![[Pasted image 20260107171120.png]]
- 
- 
- 

