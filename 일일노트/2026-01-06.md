- api.kanggyeonggu.store 80에서 jwt가 검증되야 8080 내부로 들어가니까 8080은 노출되면 안됨
- www.kanggyeonggu.store : 3000 
- 3000 에서 80 연결
- vision, chat -> ai에 모을 예정
- http를 넣으면 자동으로 무상태 프로그래밍이 된다. 
- 상태 패턴(State Pattern) : 객체의 내부 상태가 바뀔 때, 객체의 행동(메서드)도 함께 바뀌도록 만드는 디자인 패턴
- OOP, 상태기반(stateful) : state = 데이터 -> 메모리에 데이터가 저장됨 -> 보안 취약
- => 무상태의 필요성이 대두됨.
- Stateless(녹이 쓸지 않는놈) :  
- => 함수는 객체(기능만 있는거)다.   
- 

|           | fp           | oop       |
| --------- | ------------ | --------- |
|           | function(타입) | class(타입) |
| 메모리에 올라가면 | 컴포넌트         | 인스턴스      |
- 오직 React가 관리 하는 상태 컨테이너만 제공한다.
-  ![[Pasted image 20260106101640.png]]
-  ![[Pasted image 20260106101707.png]]
- 엔티티 : 속성의 집합체
- ![[Pasted image 20260106101830.png]]
- useState는 리액트꺼
- ![[Pasted image 20260106103432.png]] 
- FileUpload는 넥스트 js꺼(내가 커스텀 할 수 있는거)
- 리액트꺼는 훅 함수, 화살표 함수(function이 순수함수 안에서 정의되는거) : 이벤트 함수, 그냥 순수 함수, (NextJS) 
- 기능만 있으면 function
- 푸쉬하는 순간 컴포넌트로 바뀜.
- 파일 업로드 함수 바깥에 있으니까 바깥에는 상태가 없으니까 무상태인거고 함수 안에 있으면 상태를 가지니까 유상태.

- 상태 : 데이터(JWT)
- Next.js는 무상태, 리액트는 무상태가 아님.
- JWT Access Token은 메모리(Runtime)만 사용하고  
Refresh Token은 HttpOnly Cookie에 저장한다
- Access Token 은 리액트의 state에 보관해줘
- 
- 내가 토큰을 가지고 있는게 아니라 경량 DB 레디스로 보내버린다.(JWT 정보 저장하지 않고 보냄)
- 주스턴스 무상태
- 
- 보안성 강화
- ![[Pasted image 20260106113825.png]]
- 260106 AccessToken 는 zustand 에 저장합니다. 이 프로젝트에서 access_token 저장할 때 , 이 방식을 절대 사용하지 말고 , Access Token 은 (짧게, 5~15분): 브라우저 메모리(React state/모듈 변수)에만 보관하고 , 최종적으로  zustand 를 이용해서 스토어에 저장하도록 한다. --> 이 원칙대로 access_token 저장코드를 수정해줘

- S3 스토리지
- 상태를 모아 놓은 곳 (스토어)
- 백엔드(DB) - 데이터(변수)
- ![[Pasted image 20260106115520.png]]
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

