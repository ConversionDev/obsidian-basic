- 자바와 리액트 연동 시 CORS 오류가 생김.
- 프론트: [http://localhost:3000](http://localhost:3000)
- 백엔드: http://localhost:8080
- 두 개는 origin이 다르다. → 브라우저는 기본적으로 이걸 막음. **그걸 풀어주는 정책이 CORS** (Cross Origin Resource Sharing)
- @CrossOrigin(origins = "http://localhost:3000")
- 어? 백엔드에서 `http://localhost:3000` 은 허용이라고 했네
- origin = url(출발지) 
- 3000에서 쏘지 않은 데이터는 무시.
- 
- 스프링 클라우드 : 스트림을 사용한 이벤트 기반 마이크로서비스 
- DDD(도메인 주도 설계) : 핵심 비즈니스 개념과 규칙을 "도메인 모델"
- EDD(<u>이벤트</u> 주도 설계/개발) : UI <u>상태 전이</u>를 이벤트 -> 상태 변화 -> 부수효과 흐름으로 설계합니다.
- 부수 효과 : 추우면 옷 입는거. 
- **Command Query Responsibility Segregation**  
  명령과 조회 책임 분리)
  변경 로직과 조회 로직을 분리하자
- axios 리액트에서 8080으로 연결하고 crossorigin으로 3000에 연결   
- 연관성이 없다 : 모듈
- 서비스 하나로 다 처리한거 : 모놀리식 서비스 - 느리지만 보안이 좋음, 클라우드 서비스 힘듬 
- 분산한거 : 마이크로 서비스 - MSA : 클라우드로 가겠다. 
-  
- 검색만 하는 서버 : 넷플릭스 유레카 따로 만듬.
- 분산시키는 기준 : 각각이 독립적이고 관계성이 없어야함
- 넷플릭스 유레카에 등록된 인스턴스 중 하나로 스프링 클라우드 로드 밸런서를 통해 HTTP
- 요청을 받음.
-  ![[Pasted image 20251111110658.png]]
- 서비스 각각이 하나의 인스턴스, 로드벨런서(스프링 클라우드꺼) : 자동으로 서비스 분산시키는 장치나 소프트웨어
- 스프링 클라우드 쓰는 이유 : 도메인 네임 서버(DNS)에 올리고 배포, 자동화, 관리, 분산 처리
- 보통은 라운드 로빈 방식으로 인스턴스를 선택한다.(RR 방식)
- **순환 방식으로 요청을 분배**하는 방법
- 여러 서버나 프로세스가 있을 때 **순서대로 차례차례 돌아가며** 처리
  즉, 요청 1 → 서버 A  
  요청 2 → 서버 B  
  요청 3 → 서버 C  
  요청 4 → 서버 A … 이런 식으로 반복
- 넷플릭스 유레카 등의 검색 서비스와 통신하는 방법을 추상화한 DiscoveryClient라는 인터페이스를 제공한다.
- 로드밸런서 클라이언트”는 Spring Cloud Netflix 구조에서 **클라이언트 사이드 로드밸런싱(Client-Side Load Balancing)** 을 의미해.
- 서버 측이 아니라 **클라이언트가 로드밸런싱** 담당
- 연결 - 매핑 - 연결 시키는놈 존재
- 하나(모놀리식)일땐 docker 서비스를 분산할때 도커 여러개 로 늘어나니까 docker-compose(도커들)
- ![[Pasted image 20251111115142.png]]
- 순서 : 엣지서버 추가, 라우팅 규칙을 구성을 포함한 게이트웨이 설정, 에지서버 사용
- 엣지 서버 URL 경로를 기반으로 들어오는 요청을 라우팅 한다.
- ![[Pasted image 20251111115616.png|400]]
- 어노테이션 있으면 빈 객체
- @Component : 파이프라인 연결
- ![[Pasted image 20251111120934.png]]
- configration 컨트롤러 앞단에 설정 연결 , 엔티티 엔티티간의 연결(@one to many, @map...etc)
- 컨서레엔 : 파이프라인 연결
- 게이트웨이 만드는게 엣지서버 (이게 파사드)
- ![[Pasted image 20251111121907.png]]
- 할일 : 엣지서버(게이트웨이)를 통해서 스웨거로 보는거 -> 스웨거에서 게이트웨이 볼수 있음.
- 요청 URL → 처리할 서비스” 매핑
- 이니셜라이저 하기전에 멀티모듈 부터 해야함.
- https://dkswnkk.tistory.com/691
- `gateway`안에 구글 oauth -> secret ->` configration` -> `eureka`(discovery 어디로 보낼지 길 찾아 주는놈)
- gateway가 파사드가 됨 문짝 맨앞에 들어오니까. configration이 중앙이니까 구성 중앙화
- 중앙 구성 저장소(중간 DB 느낌), 일시적인 구성 서버 접속 문제에 대한 복원력이 개선된다.
- application.yaml : 
- 키 하나에 저장소 하나.
- 
- 
- 

