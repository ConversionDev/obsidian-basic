 ### 오케스트레이션(Orchestration)
- 여러 컴퓨터 시스템, 애플리케이션, 서비스 또는 작업을 조정하고 관리하여 전체적인 워크플로우를 실행하는 것을 말합니다
- `흐름 제어(flow Control)` : Ai
- `상태관리 (State Management)` : state(현재시점), status(의지를 가지고 한 것의 결과), 관리가 나오면 (=매니지먼트), CRUD(클러드)의 결과

- property들 = props state가 props가 되려면 뭔가 행위가 일어나야 하는데 이걸 해주는게 리덕스 리덕스는 `상태 관리자`
-             redux
- state - crud - props
-                     flux

- 프로젝트 : 프로그램을 만들기 위한 과정
- 프로그램(정적인 상태), 프로세스(스레드의 집합)
- 큐브 안에서 멈춰 있는 상태에서 데이터의 흐름이 일어남
- 
- 흐름의 종류 
- stream(가장 큰 개념 이 안에 스레드, flow, flux가 있음)
- 스레드 : UI-UX, ACC(APP), PSC(DB)(전원이 올라간 상태), 전원이 내려가면(메소드)
- 자바 넘겨주는거 파라미터
- ![[Pasted image 20251119112125.png]]
- flow : Ai , flux : 리액트에서의 데이터 흐름, thread  
-  
- 리액트 : 컴포넌트
- 화면 : 컨테이너 , 도커는 컨테이너를 만들어줌
- 리덕스 : state management 
-              Reactiflux 
-  
- 자바에서의 기능 메소드, 리액트의 기능 훅 
- 메모이제이션 : 동일한 입력에 대해 계산된 값을 캐시에 저장하고 재사용 = 메모 (메멘토)
- 
- ### **메멘토 패턴(Memento)**

- 어떤 객체의 **이전 상태(state)를 저장**해둔다.
    
- 필요할 때 **그 상태를 복원**한다.
    
- “원래 상태를 다시 꺼내와서 사용하는 것”
    

### **메모이제이션(Memoization)**

- 어떤 함수의 **입력(input)** → 결과(output)를 **저장**해둔다.
    
- 다시 동일 입력이 왔을 때 **저장된 output을 복원**함.
    

➡ 즉, **“상태를 저장하고 다시 꺼내 쓴다”**는 측면에서 메멘토와 연결될 수 있음.

- useCallback : 문신으로 몸에 백승헌한테 100원줘야한다고 써둠, 자주씀 축구의 삼각패스, 누구한테 주고 받다. 주는게 dispatch, handle - 콜백 함수
- useEffect : 부가작용을(사이드 이펙트) 위한 훅, 시간 맞추는 거다.
- props와 state가 일치 해야함.
- ex) 일기장에 나한테도 state로 12:00되야 하고 던지는 것도 props도 12:00여야 하니까 일치시켜야함. 
-  클라이언트 사이드 렌더링(CSR) : 가지고 있다가 그려줄거냐 <-> 서버 사이드 렌더링(SSR) - 팀마다 판단 근거가 있어야함. : 자바 갔다 와서 뿌려줄거냐 => 페이지와 페이지 간의 이동방식
- 컴포넌트는 한페이지에 하나. 페이지 단위가 컴포넌트, 페이지 단위로! 우리 프로젝트는 페이지에서 페이지로 넘어갈 일이 없음. 근데 CSR 할거같음
- 액션 : 콜백을 핸들링 하겠다. 값을 갖고 있다가 처리하겠다.
- 
- 둘다 접속 : 동기, 반응이 바로 와야할 때 , 반응이 바로 올 필요가 없을 때 : 비동기 - 문자(메모리듬)
- 반응이 바로 와야할 때 : 전화  전화가 좋아 문자가 좋아? 컨텍스트에 따라 다름
- 송금 - 무소식이면 불안하니까 이럴때는 동기, 알람 - 동기
- dm은 비동기
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

