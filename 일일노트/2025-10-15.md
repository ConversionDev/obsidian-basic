## 9 : 20 ~ 10 : 30
### 개인 복습
![[Pasted image 20251015092919.png|400]]

- 총 정리하면 프론트에서 키와 값으로 받아올때 키는 상수고 값은 변수고 백에서 받아서 처리 하는 순간 값은 매개변수가 되고 그 결과가 실제 값인 거고, 프론트에서 변수로 넘어 올 때는 쓰레기 값이 넘어 올 수 있으니 프론트에서 1차 유효성 검증들하고 백에서 2차 유효성 검증을 한다음에 실질적으로 의미있는 값(데이터)만 도출 되게 한다. 이때 프론트에서 변수는 개체값만 넘기는거고 그 개체값을 받아서 기능을 구현하는것이 백이다. 이때 리퀘스트 파람을 통해 classpath라는 길로 html에서 자바로 값을 가져가고 그 받은 값을 return해서 실질적 value로 도출한다 데이터 베이스에서는 더블쿼트안의 값을 자연어로 그대로 프론트에서 유효성 검증 후 받아와서 백에서 유효성 검증을 하고 값을 도출 하는데, 이때 예를들어 자바에서 password와 html에서 password가 이진수에서 가르키는 숫자가 다르므로 자연어로 그대로 가져와서 데이터베이스에 저장한다

- > 매개변수는 일시적으로 값을 전달하는 문,  
> 필드는 그 값을 객체 안에 보관하는 창고.” 즉
- 프론트에서 넘어온 쿼리스트링 값 → 매개변수로 들어옴
    
- 매개변수로 받은 값 → 필드에 저장됨
    
- 필드에 값이 저장되면 그때부터 그 객체의 **상태**가 만들어짐

### 복습
- ![[Pasted image 20251015093534.png|500]]
- 같은 강에 두 번 발을 담글 수 없다 -> `stream` : 강 -> 스트리밍 -> 변수(variable) ->
	- 상태에 대한 변화, 흘러가고 소멸됨
		- 주소의 상태가 변함 -> 쭉 가고 없어짐 -> 아이디랑 비밀번호는 변수로 넣음 -> 강물 처럼쭉 지나면 없어짐 => `변수는 스트림으로 움직인다`
- 존재하는 것은 존재하고, 존재하지 않는 것은 존재하지 않는다. -> 상수(constant)
	 값 자체는 상수지만 그 값의 상태가 변화하는 것.
- 처음에 프론트에서는 데이터를 입력 하지만 아직까지는 <U>데이터가 아니라 value인데</u> 흘러가다가 정착하는 곳이 DB임. 자바에서는 옳은 값인지 아닌지 아직까지는 모르니까 value고 valid 유효성 검사를 통해서 `가치있는 정보가 되었을 때 DB`에 저장.
- 스트림 : variable에서 constant로 가는 일련의 과정
-  자연의 강물을 인위적으로 내집 앞으로 당기는 것 -> 당길라면 `수로`가 필요함 ->` 파이프라인`이 필요함 -> 파이프라인 파이프라인은 직렬로 연결해야 하고 DB에 저장되기 전까지 병렬로 연결되는게 아니라 직렬로 연결하는 것이 우리가 하는 작업. -> DB에 저장된 후에는 ai가 이걸 보고 학습 하는것.
- value는 -> variable에 담김.
- ?email = kang@test.com& variable : email , kang 뒤 value, `=(할당연산자)`
- 이메일의 주소에 강 머시기가 담겨 있다. 담겨있는 것도 결국엔 같다고 생각함
- 이메일이라는 주소가 바뀐게 아니라 그 안의 변수가 바뀐거다. variable이 value를 담아서 떠다님. -> 여기까지 `스트림` -> 인위적으로 특정 서버등등 원하는 곳을로 조정하는 것 `파이프라인`
- 원래 흘러가도록 두던걸 다시 당겨오는 게 `return`
- 도메인 : 같이 있는 지식이다  Controller -> Service로 연결 하는게 정석. Service -> DB로 가는 게 중요 하니까 -> (보안)Domain으로 넘어갈때는 두가지로 쪼개짐. (비유 : 다른 곳은 파이프라인으로 그냥 연결하다가 워낙 중요하니까 철문 담) -> `DTO`(쿠팡에서 그냥 음식물 전달하는건 글케 안빡셈 보안) - 그냥 옮겨 담는 거고, `VO`(취급 주의 물품) -> 값 자체에 의미가 있음 => 당연히 DTO가 빠름.

## 10 : 30 ~ 11 : 20
- ![[Pasted image 20251015104319.png]]
- String name 에서 name이 valuable이고 실제값은 value여서 은닉화 되어 있음. 그래서 은닉화 된 정보를 보기 위해서 System.out으로 출력함 -> 좋은 코드 아님.
- 단수와 복수를 다르게 취급함. 변수가 하나면 단수고 아이디와 비번은 합쳐쳐야 의미를 가지니까 두가지를 합치면 속성이 됨. email과 비번이 따로 떨어져있으면 의미를 지니지 않음 두가지가 하나로 합쳐져야 의미가 생김.
- 라운드 브레스()가 있으면 메소드(기능) 없으면 속성.
- 대문자 : 객체 소문자 : 속성.
- ![[Pasted image 20251015110816.png]]
- getter는 볼수만 있고 setter는 입력만 됨(getter: 읽기 전용, setter: 은행예금) ->setter 보안 땜에.
- 의미를 갖는다 = 맥락을 갖는다 = 컨텍스트를 갖는다 => 결합은 맥락을 갖게 한다.

## 11 : 30 ~ 12 : 20
- 전체는 variable인데 private String email;은 property
- ![[Pasted image 20251015113842.png]]
- 전역변수, ()안에 name 지역변수, 속성, ()메소드 기능.
- ![[Pasted image 20251015114641.png]]
- 이말이 깃허브에 New (어떤 저장소를 만드는것) ()파라미터존, ()가 없는 곳은 클래스 
- LoginDTO 클래스를 LoginDTO()로 기능을 하게 만들어라. 전체통을 그대로 DB로 가져간다. 파이프라인에 담긴 값을 서비스쪽으로 옮김
- 속성은 감추고 기능은 열어라.
- 메소드는 대부분 public(보안하는 경우에는 private), 속성은 private, get age 나이를 말함.
- public 기능을 만든다.
- ![[Pasted image 20251015113842.png]]
- 인간의 자연어로 담은것 Type. 자바에서 숫자 Integer, 속성에 따라서 밑에 기능이 결정됨. 문자면 문자고 숫자면 숫자 위와 같은 상황의 경우에 String이니까 문자로 받아야함.
- 메소드는 게터와 세터로 나뉨. 게터와 세터의 구분은 파라미터의 유무로 나뉨.
- ![[Pasted image 20251015120043.png]]
- 게터는 반환하는 값이 없고 세터는 반환하는 값이 없는데 파라미터가 있으니까 ㄱㅊ
- this. Controller가 이미 가지고 있는 값이고 email은 밖에 있는 값 비교해서 맞으면 true 아니면 false. =는 파이프라인으로 서비스의 name이랑 연결하는거. 
- void가 판단한 값을 어디에 두고 return값으로 직접 받지 않음.
- boolean : 참과 거짓을 판별한다.
- String 문자(이메일) int 정수(은행예적금,출금 100만원 넣었는데 100맞는지 숫자를 파악해야 하니까) boolean 참/거짓
- Contoller -> Service로 가는데 그 이유가 파이프라인이기 때문에.
- 속성은 메소드하고 동등하다.
## 12 : 30 ~ 13 : 20
- 컨트롤러에 서비스 프로펄티를 설정하는 과정
- ![[Pasted image 20251015124132.png]]
- =로 서비스와 컨트롤러가 똑같이 연결되고 똑같이 연결된건 DTO에 남아서 서비스로 보낸다.

## 14 : 30 ~ 15 : 20

## 15 : 30 ~ 16 : 20

## 16 : 30 ~ 17 : 20
- VO value object - Data analyst
- DTO(variable) 화면 VO(value) 데이터 -> 일치하는지 로직 작성해야함.
- 데이터 베이스에 준 정보 , aa,bb 
- dto와 vo만나서 서비스가 만들어짐
- ![[Pasted image 20251015165740.png]]
- DTO와 VO 값을 서로 비교하기 위해서 가져온다.
## 17 : 20 ~ 18 : 20