- 화면까지 연결할 때 쓴 페턴
	- 파사드 패턴 = 문 = 게이트웨이(=디스커버리 유레카 컨피그)

##### 복습 / 총 정리
- 컨텍스트는 두가지 의미
	- 맥락에서 하나
	- 환경에서 하나: 컴포넌트-컨테이너-컨텍스트
		- 이걸 코드로 이야기하면, 컴포넌트는 스프링부트, 리액트에 있어. sql에는 없어(SQL에서는 객체가 없으니 컴포넌트가 없어. 그래서 컨텍스트가 없어. 그래서 그 역할을 자바가 해줘. ACTX를 쭉 내리면 PCTX가 돼. )
		- 컴포넌트(OOP)를 AOP로 엮어.  면은 선으로 이루어져있고, 면이 적분, 면을 자세히 봐서 선으로 보이는 게 미분
		- 컴포넌트는 1차원, AOP로 엮으니 2차원이 돼(컨테이너)
		- (컨테이너)면을 합치니 정육면체가 되는 것 처럼 보여. 스레드로 면끼리 연결되어있어. = 컨텍스트
			- *사실, ACTX 나 PCTX를 그릴 때 처럼 컨텍스트를 면으로 그리긴 했는데, 컨테이너가 면이고 그 면을 모은 큰 면이 컨텍스트라고 생각하면 돼*
		------------------------------------------------
		- @서비스, @컨트롤러 각각 하나는 -> 0차원 (하나만 있으면 일을 못해)
		- @서비스, @컨트롤러 등으로 컴포넌트(파이프라인) 만들어 -> 1차원
		- 도커파일이 컴포넌트를 모아서 컨테이너로 만들어 -> 2차원
		- 도커 컴포즈는 컨테이너를 모아서 -> 3차원			
		- 3차원을 여러개 복제하면서 인공지능을 만들어 -> 4차원
		- 컨텍스트가 박스형태 같지만, 어플리케이션컨텍스트랑 퍼시스턴스컨텍스트는 면인데 왜 박스를 컨텍스트라고 하는가?
			- 동적으로 생긴다는 생각을 하면, 스레드들이 점을 내리면서 면이되고 박스가 되는 순간들이 있다고 생각하면 돼
	- 검색) 딥러닝에서 텐서란 무엇인가?
		- 스칼라(0차원, @서비스, @컨트롤러 각각 하나), 벡터(1차원, 컴포넌트), 행렬(2차원, 컨테이너, 메트릭스)
		- 컨테이너를 큐브라고도 하며, 이 관점에서 3차원임. 이것을 ==텐서==라고 함
		- 사람은 3차원이라 한 차원 아래인 2차원만 볼 수 있어. 선을 볼 수 있다 생각하지만, 그 선은 사실 면 상태인거지
- groupId 와 artifactId
	- 컨텍스트가 하나면 굳이 이름을 주지 않아도 돼. 여러개일 때 이름을 붙여줘야 해
	- 구분하지 않으면 존재하지 않는 것
	- 자바에서 @Id 가 인조키이자 palyer 폴더(컨테이너) 하나를 관통하는 것으로 이것이 개념적으로 artifactId를 뜻하는 거지.
	- 검색) UUID : 전 세계, 우주에서 단 하나만 존재하는 값 (주민번호, 전화번호)
	- @Id 가 UUID 인거지. 그리고 차원을 올려도 각각 고유 id가 있으므로 그게 다 UUID.
	- 그래서 구분이 가능하니까 객체로 볼 수 있어 player 폴더랑 team 폴더를 구분할 수 있
	- api ui 등을 묶어서 도메인이 되면 도메인은 컨텍스트의 집합이자 프로젝트가 되는거고
	- groupId 와 artifactId는 차원이 올라가면서 계속 바뀜. 그러다 보니 상대적으로 자꾸 바뀌는 문제가 발생함 그래서 각 단계마다 이름을 줌
		- GPT) uri와 url 의 차이가 뭐야? 그리고 msa에서 로드벨렌서는 뭐야? (사진 참고)
			- 사진을 보면 soccer **마이크로서비스** 하나이자 **컨테이너** 하나의 id는 ==**uri**== 임
				- 컴포넌트 아이디는 long id
			- 로드벨런서는 마이크로서비스로 분리하여 운영하는 방식
			- URL = 도메인 + 컨텍스트(폴더링중에서 api)+uri+LB
				- 도메인=컨텍스트 들
			- api 부터 다음까지: uri / soccer 부터 다음까지: LB(로드벨런서)
			- **==uri**가 컨텍스트까지(ex. api) / **LB**가 컨테이너까지 / **long id**(@Id) 컴포넌트까지==
		- *하나는 바로 밑에 자식만, **는 밑에 모든 자식들을
		- : 는 차원의 변화를 의미
		- predicates는 예측하다의 의미로 생각해
		![[Pasted image 20251118105959.png]]

------------
##### 도커 컴포즈 야물
- 도커 컴포즈는 컨테이너들을 연결해. 3차원을 만들어
- GPT) 도커 컴포즈 야물 최상위 상단에 버전을 주는 게 좋아 안 주는 게 좋아?
	- 없어야 해. 있으면 아마존에서 오류나. 만약 커서가 자동으로 만들었다면 나는 버전 명시 안 하겠다고 훈련시켜야 해
- 도커 컴포즈 야물은 컨텍스트를 만드는 애 인거지
- . 은 현재를 말해 
- networks 부분을 도커 네트워크라고 부름. 어제 배운거. 아래 써있는 스프링 클라우드는 이름일 뿐
	- 같은 컨텍스트 안에서는 같은 이름을 써야 해
- depends_on은 나 있기 전에 디펜즈온에 있는 애가 먼저 있어야 한다. 부모자식
	----
- GPT) 도커 컴포즈에서 볼륨이란?
		- 컨테이너의 수명주기와 독립적으로 데이터를 영구적으로 저장하고 관리하는 것
		- 컨테이너가 사라져도 정보 유지
		- ui 서버는 볼륨이 없어야지. e-book 처럼 계속 사라지는 거니까
	![[Pasted image 20251118115445.png]]

--------------
##### 화면
- 웹 애플리케이션 책 보기 1페이지 부터
- 자바에서 컴포넌트는 @id / 타입스크립트에서는 컴포넌트 단위를 type이라고 함
- GPT) 리액트에서 구조분해할당이 뭐야?
	- 구조가 패키지, (구조란 클래스가 여러개라는 점)
- 넥스트는 프레임워크고 리액트는 라이브러리다. 라이브러리는 디펜전시를 임포트하는 것
- 함수 컴포넌트 = FC
- 리액트의 특징
	- 단방향 데이터 전달
	- 컴포넌트 지향 / 함수 컴포넌트(FC)
	- 플럭스 아키텍처와의 친화성
		- 플럭스란: 리액트에서 데이터 흐름
- lb가 라우터 / 리엑트에서도 라우터가 있다
- 리덕스 = 리엑트+플럭스
- 컴포넌트를 만들면 컨텍스트가 생긴다는 것, 라우터는 우리가 만들어야 해
- props 프롭스 와 state 스테이트 차이
	- **컴포넌트(하나의 페이지) 안에 있는 상태는 state, 페이지 밖에서는 props 프롭스**
	- props  > state > props > 자바로 이동(props가)
- 컴포넌트-리액트 / 컨테이너-tsx(페이지) / 컨텍스트-리덕스
- 리덕스에서 리액트 라우팅을 함
- @index.ts 에서 persist 를 사용하여 PCTX로 이어지게 함