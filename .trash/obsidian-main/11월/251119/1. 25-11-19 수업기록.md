- 다중 에이전트 시스템 = MCP / KANANA 1.5 모델 고성능 한국어 LLM이므로 사용하면 가산점(네이버도 있겠네)
- 리덕스는 상태 관리자임
	- 리액트는 말만 하면 다 만들어줌. 스프링과의 연결성 즉, 컨텍스트를 알아야 하기 때문에 사람이 해야하는 것임.
- 순수 = 노테이션 / 순수하지 않은 것 = 어노테이션
- 빈객체를 만드는 것이 팩토리메서드. 컨텍스트를 만들면 그게 팩토리임
- 노테이션 처리하면 조건이 맞을 때만 보여 (에러)

#### 복습
- 컴포넌트인 선이 모이면 면처럼 보이는 순간이 옴. 그 때를 컨테이너라고 함
- 컴테이너가 여러 장 붙어서 더 큰 면이 되면 그 때를 컨텍스트라고 함

#### 오전수업
- 모든 것은 큐브로 되어있고, 이 큐브 안에서 데이터 흐름이 있으며 4가지로 구분 됨
	- FLOW STREAM THREAD FLUX
		- STREAM : 가장 큰 개념. 세 개를 다 합치면 STREAM
		- THREAD : 어플리케이션 컨텍스트, 퍼시스턴스 컨텍스트, 리액트 컨텍스트 사이의 데이터 흐름 (전원이 꺼지면 깡통이니까 메서드라고 부름. 전원이 흐르면 스레드)
		- FLOW : 다차원에서 데이터 흐름
		- FLUX : 리액트에서 데이터 흐름

	- 프로젝트 프로세스 프로그램
		- 프로그램을 실행하면 프로세스
		- 프로그램은 정적인 상태, 그 안에 흐르는 것이 프로세스
		- 실행 한 게 프로그램
		- 실행 전이 프로젝트
		- 프로젝트는 프로그램 만드는 과정
		- 시즌 1개 =프로그램 / 시즌 전체 = 프로젝트

	- 관리 = CRUD 크러드 = management (이렇게 부르지 말고 크러드라고 함)
		- 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)  
		- save / get->find / up / delete
		- STATE 를 CRUD 하면 PROPS 가 되며, 이런 흐름을 FLUX라고 함. CRUD를 해주는 애를 리덕스라고 함
		-  CRUD의 결과 = STATUS
---------
-  ACTX - PCTX 사이 데이터 흐름이 **스레드**, **스토어**(화면 컨텍스트)와 ACTX 사이 데이터 흐름이 **플럭스**

- 플럭스는 단방향 / 스레드는 양방향임. 이름을 따로 짓는가? 플럭스는 단방향이면 돌아오는 값을 어떻게 처리하는가? >> 그래서 플럭스에서 리덕스로 진화함
	- 단방향은 양쪽 흐름이 없다는 게 아니라 중앙분리대가 없다는 느낌
	- ==??? 컴포넌트 = 리액트==
	- 리덕스는 공간일 뿐, 흐름은 플럭스임 = 플럭스를 유지하지만 중앙분리대를 만들어 주는 것
	- 플럭스는 리액트 생태계에서 state를 한 방향으로만 흐르게 만드는 아키텍처 패턴임
	- state props 둘다 단방향 
	
	- 플럭스는 4가지 컴포넌트로 구성됨(페이스북이 제안)
		- store: 좁은 도로에서 옆에 세울 수 있는 그런 공간 느낌임
		- 상태는 store에만 있다
		- 상태 변경은 store만 할 수 있다.

- 자바에서 기능을 메서드라고 한 것 처럼, 리액트에서는 기능을 훅이라고 함
	- useState : 컴포넌트 안에
	- 서만 사용하는 상태를 다루기 위한 훅
	- 컴포넌트 밖에서 상태를 다루기 위한 훅은 useProps 라고 하겠지
	- useReducer : 사라짐
	- useMemo(메모이제이션 훅) : 비용이 많이 드는 함수 호출의 결과를 캐시(저장)하여, 동일한 입력에 대한 함수 호출이 반복될 때마다 계산을 다시 수행하는 대신, 저장된 결과를 즉시 반환하도록 하는 기법
	- useCallback: 줬다가 돌려 받는 것. 그럴려면 일단 줘야된다
	- useEffect: = 부가 작용 = side efffect : state와 props는 같아야 하므로 둘 다 업데이트 됨
	- SSR 과 CSR: 
		- 서버 사이드 렌더링 SSR: 자바갔다와서 새로 그릴거냐 (캐시가 어렵)
		- 클라이언트 사이드 렌더링 CSR: 갖고있다가 새로 그릴거냐
	- 페이지 하나 당 컴포넌트 하나로 봐. (컨서레엔도 여러개인데 하나로 보잖아)
		- 페이지는 아톰으로 구성
	- 어플리케이션 컨텍스트는 빈객체를 저장해 
	- 리덕스=주스텐드 인 정도
	- handle~ 들어가면 콜백 함수, use~ 들어가면 훅


- 동기: 항상 교차엔티티와 **연결**되어있어야 해(전화, 문자알람)
- 비동기: 그러지 않아도 돼 (문자) 메모리 사용



------------
- 플럭스와 리덕스

| 구분      | FLUX  | Redux |
| ------- | ----- | ----- |
| store 수 | 여러 개  | 1개    |
| 상태 불변성  | 강제 아님 | 강제    |
| 복잡도     | 복잡    | 단순    |

----------
##### 오후 (화면 코드)

- 화면은 리덕스를 쓸지 뭘 쓸지 표준화 된 게 없음
- 우리는 라이브러리를 zustand를 사용할 거임
- 스토어는 1개 ==>무조건 고정인 것
- CURSOR) @frontend 여기에 컨텍스트로 STORE를 반드시 1개만 만들고, 이것을 관리하는 라이브러리로 zustand를 사용하려고 해. 해당과정에 대해서 전략을 작성해줘
- 프론트엔드에서는 커서로 진행하면 이전 단계로 되돌리기가 굉장히 어려움. 다 깨짐. 따라서 커서로 프롬프트 입력할 때 "전략"을 작성해달라고 해야해. 
- ts: / tsx: 컨텍스트