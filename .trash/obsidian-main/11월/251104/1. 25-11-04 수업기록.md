- - **“옛날 것”**, 오래된 기술이나 구조를 말함.  
    예: 클래식 자바, 스위치문, OOP만 사용하는 방식 등
	→ **마이그레이션(Migration)** = 더 좋은 환경으로 “이사”하는 과정 (즉, **고도화 작업**)

- 책의 목차에서 한글부분이 PK, 페이지 넘버=키=long

- 데이터 매핑과 엔티티 이해
	- 매핑(Mapping)
		- **자바 ↔ 데이터베이스**처럼 “이기종 언어” 사이에서 **데이터를 연결(파이프라인)** 하는 일
		- ( ) 안에는 **종착지(destination)** 를 **더블쿼터(" ")와 자연어**로 작성해야 함 → 약속!
		- @entity :나는 엔티티로써 디비랑 연결하는 역할을 할거야
		- @table : 엔티티가 연결 할 테이블의 이름은 @Table(name = "players") 처럼 괄호 안에 명시할거야


- 방향성 (파이프라인 흐름)
	- **→ 방향:** `request` (요청, 데이터를 보내는 방향)
	- **← 방향:** `response` (응답, 데이터를 받는 방향)

- 도메인은 DTO, VO, ENTITY 가 있음
	- 도메인은 객체냐 개체(엔티티)냐로 나뉨.
		- 객체: 디티오, 브이오
		- 개체: 엔티티
	- 도메인에서 00엔티티 라고 안쓰고 엔티티를 생략하기도 함.

- 객체는 request object 와 response object 로 나뉨.
	- 메신저는 레파지토리에서 만들어서 컨트롤러 방향으로 움직이니까 response object임. 
	-  DTO는 request object임
	
	- response 는 게터만 있어야 함. 결과를 바꾸면 안되니까
	- 모든 자연의 구조는 1:多 임. 그 논리에 따라
	- new 했다는 건 객체임. 엔티티 아님
	- 원래 위 사진(OOP) 에처럼 생겼는데 아래로 바꿈. 메신저에 하나만 넣어야되는데 200이랑 " "  까지 두 개가 들어가니까 오류나. 그래서 올알규먼츠로 두개를 하나의 기성품으로 만들어 버린거야. 
		![[Pasted image 20251104104613.png]]
		![[Pasted image 20251104104506.png]]
	- 뉴 메신저(위 사진 12번줄)를 스칼라로 바꿔줘: 메모리를 쓰지 않고도 진행가능
		- ==람다==라고 불러 (FP)
		![[Pasted image 20251104111226.png]]
		![[Pasted image 20251104110907.png]]
		- 아래처럼 정의해. 리턴에서 시작해서 오른쪽으로 갔다가 왼쪽으로 들어오는 순서. 
			![[Pasted image 20251104112023.png]]
- 홈컨트롤러에 있는 메신저는 화면이 살아있냐 죽어있냐 판단. 레파지토리에서 만든 메신저는 로그인 성공 실패를 판단. 그 둘 메신저는 클래스는 같은데 인스턴스가 다른 것.


-----
- GPT) IT 세계에서 마이그레이션이란 업무는 뭘 하는거야? 쉽게 설명
		![[Pasted image 20251104115416.png]]
	- 마이그레이션 = 좋은 곳으로 이사하는 것 = 고도화 작업
	- 마르지 않는 샘의 직업임
	- 클래식자바를 모던자바로 바꿀 수 있어야. 둘 다 알아야된다는거지

- VAR(변수) 란 무엇인가?
	- 서비스에서 타입을 VAR 로 바꿔. 모든 타입을 VAR로 바꾸되 파이프라인은 건들지 마
	- 그 뒤에 지울거야
	- 근데 가끔 인스턴스를 지우지 못하는 것도 있으니까 그럴 땐 타입을 VAR 로 지정해
	- 스위치 케이스로 하는 게 레거시. 옛날 거. 객체지향도 옛날거임. 함수형으로 가야됨. OOP가 아닌 FP로.
	- FP 로 간다는 것은 람다형식을 쓴다는 것
	- 우리는 모던 자바를 해야 돼.
	- GPT) 인공지능 AI 프로그램을 작성하려고 해. 나는 빠른 속도를 원해. 이 때 객체지향프로그램과 함수형 중에서 어느 것이 더 나은 선택일까? 내가 만든 프로그램은 리액트+스프링부트+랭체인+포스트그리 도커로 구성될거야. 전체 프로젝트를 통일할 수 있는 패러다임을 둘 중에 하나로 추천해줘.
	- gof의 디자인 패턴: 어렵지만 가치가 있다. oop에서 사용하는 거긴 해


- 디자인패턴: 크게 세가지. 생성 구조 행동 > 이진으로 나눠. 객체냐 생성이냐 
	- 생성 -> new : 전부 new를 제거하라. 람다에서 쓴 new를 없애는 것.
	- 구조 -> 속성
	- 행동 -> 기능

- 람다e에서 쓴 뉴를 지우고싶어. >> 프롬프트 아래처럼 입력 >> 디자인패턴 중 빌더패턴 쓰기 ==빌드패턴으로 작성해줘==
	- 빌더는 올아그스를 대체한다 
	![[Pasted image 20251104143741.png]]

	- @NoArgsConstructor :  추가하고싶을 때, 수정하고싶을 때, 카페에서 만드는 커피, 게터와 세터가 있어야 돼
	- @AllArgsConstructor: 다 담아서 나오는 레쓰비, 수정하면 안돼, 게터만 있어야 돼


- 나는 함수형 마이크로서비스로 스프링부트와 리액트 아키텍처를 사용하는데, @restcontroller와 @controller 중 뭘써야하는지 이유와 함께 쉽게 설명해줘
	- 마이크로로 할려고 모놀리식이 나이고
	- oop(객체지향) 함수형으로 전환하려고: 빌더쓰고 레스트컨트롤러

- 모놀리식과 마이크로의 차이: 은행같은데가 서버가 하나인 모놀리식. 마이크로는 작은 서비스로 나눌 수 있음. 클라우드에 올리면 다 마이크로임

- api를 4개를 jpa로 자동생성을 하고싶어. 어떻게 만들면 돼?
	-  클로드) @HomeController.java 여기서 docs에서 실행했을 때 스웨거가 작동하도록 해줘.
	-  다음 링크에 있는 내용을 아래 사진처럼 폴더 만들어서 자바 파일들 만들어주고 클로드한테 시키기. (자바 파일까지는 직접 손으로 만들고 링크 내용을 클로드한테 주면서 DTO만들어 달라고 하기) [https://parksrazor.tistory.com/892](https://parksrazor.tistory.com/892)![[Pasted image 20251105094958.png]]
	- 엔티티에는 @Id private long id; -> 이거 추가 해줘야 함![[Pasted image 20251105095221.png]]


총 23개
0 프로토타입 : 원형
1 싱글턴
2 이터레이터 이 = 2
3 팩토리 쓰리팩
4 포사드 포=4
5 옵저버 오=5
6 커맨드 육군
7 빌더 칠 빌
8 브릿지 : 다리 > 팔 > 숫자팔
9 구성 구 = 9
10 템플릿 템 = 텐 
11 전략 : 축구
12 데코 디셈버
13 추상 주상전하 카드게임 13번이 왕임
14 중재자 중2 14살 
15 방문자 (= 비지터패턴) : 문 moon 보름은 15일
16 번역 ㅂ
17 상태 ㅅ
18 플라이웨이트 48키로 = 18
19 책임 연쇄 : 식구(가족)
20 메멘토 내친구 2000년대 개봉한 영화
21 프록시 변호사 = 이 일을 처리해줘 = 이 일 = 2 1 
22 어댑터 220v


---------------
- 생성패턴 (5)
	0 프로토타입
	1 싱글턴
	3 팩토리
	7 빌더
	13 추상

- 구조패턴 ((7))
	4 파사드
	8 브릿지
	9 구성
	12 데코
	18 플라이웨이트
	21 프록시
	22 어댑터

- 행동패턴 (11):  행동패턴은 메서드 역할
	2 이터레이터
	5 옵저버
	6 커맨드
	10 템플릿
	11 전략
	14 중재자
	15 방문자
	16 번역
	17 상태
	19 책임연쇄
	20 메멘토
	