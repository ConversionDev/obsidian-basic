- 복습
	- 종단 = OOP = 파이프라인
	- 횡단 = AOP 
	- 우리는 OOP와 AOP를 같이 쓸 줄 알아야 하는 것
	- AOP를 사용하게 되면 전체 OOP를 보게 되는 것
	---------
	- 관심과 책임의 차이
		-  책임 체인(responsibility): 다음 단계와 상관이 있음. 종단. 보여
		-  관심(oop, cross cutting): 다음 단계와 상관이 없음. 횡단. 안보여


- 유레카 뜬 화면을 에지서버 혹은 gateway라고 함. 엣지서버는 좀 구림
- 유레카 화면 보면서 설명
	![[Pasted image 20251113094934.png]]
	
	- status 와 state 의 차이
		- state는 특정 시점. 내가 요청하는 것과 상관 없음. (비오는 것)
		- status는 결과 (비와서 우산을 씀)
		- 맥락 고려하라는 것은 state를 보는 것임
		- 개발자는 state를 만드는 것임. 소비자가 status를 사용하는 것
	- instances
		- 유레카에서 인스턴스는 마이크로서비스를 뜻함
		- 위 사진에서는 no instances available 이니까 등록된 인스턴스는 있어도 활성화 된 인스턴스(마이크로서비스)가 없다는 것
		- 모든 폴더에 있는 apiapplication을 눌러야 활성화 되는건데, 다 누르고 다닐 수는 없으니까 한 번에 키는 작업이 필요해  = 도커 docker compose 로 한 번에 켤 수 있다
		- 인스턴스 하나 당 도커 하나는 맞음
- 라우팅
	- 게이트웨이에서 책임체인으로 가는 길
	- 라우팅을 하는 녀석을 라우터라고 함
	- 게이트 웨이 세개 중 디스커버리만 라우터임

-----
### 도커로 한번에 키는데, 유레카에 모든인스턴스가 다 떠 = 도커 컴포즈

- 도커랑 쿠버는 yaml을 사용함. 도커에서 쿠버로 변환되는 중
- 도커 저장공간: 볼륨-랜덤으로 디스크에, 이미지-다운로드에, 컨테이너-메모리에
- 루트에는 docker-compose.yaml을, 나머지 모든 폴더에는 Dockerfile 만들어줌
- 컨피그의 도커파일에 다음 내용 넣고, 클로드한테 나머지 도커파일도 해당 양식으로 작성해달라고 해
	FROM openjdk:21-slim  
	VOLUME _/tmp_  
	RUN _apt-get_ _update_ _&&_ _apt-get_ _install_ _-y_ _curl_  
	COPY _./build/libs/*.jar_ _config-server.jar_  
	ENTRYPOINT _[_"java"_,_ "-jar"_,_ "/config-server.jar"_]_
- docker-compose.yaml여기에 각각의 Dockerfile과 연동하도록 등록해줘
- 안 될 경우) 도커 컴포즈 설치해줘



----
- java, py, ts >> 얘네들은 함수가 있어서 oop
- html, sql >> 얘네들은 함수가 없어서 another

- 디자인패턴은 생성/구조/행동으로 나뉨
- 로직=기능=함수 / 구조=속성
- 구조는 병렬인데, 논리적으로는 체인을 구성하며 직렬임(파이프라인)
- 병렬을 직렬화 하는 것이 serialization. 현재는 병렬인 것이지. 런 돌린 이후에 일어나는 일이니 우리가 볼 수는 없어
- DSL 에는 yaml과 jsonl이 있음.
	- 데이터를 직렬한 게 jsonl / 
	- 컨테이너를 직렬한 게 yaml / 컨테이너 직렬= 파이프라인 = 데이터가 다니는 길
	- 컨테이너 = SQL-릴레이션, 자바-클래스, 리액트-컴포넌트 
		- 릴레이션들이 직렬화 되어있으면 가장 앞에 가장 자식이 있어

- 사진 참고 하면서 보기
	![[Pasted image 20251113125011.png]]
	- 빌드: 병렬을 직렬로 바꾸는 직렬화 S
	- 8번 라인: 앞이 http(인터넷) 뒤가 라우터(인트라넷)
	- 둘은 보안 때문에 회사에서는 다르게 쓰는 경우가 많고, 꼭 같아야 하는 것은 아니지만 우리는 같게 쓰는 게 좋을 것 같음
	- 노드가 점, 선이 직렬화된 파이프라인
		- 노드가 점 선이 엣지
------
- 아래 사진처럼 도커 컴포즈에서 맨 밑에 네트워크 형태가 모든 컨테이너들의 네트워크 형태와 동일해야 데이터가 공급됨.
		![[Pasted image 20251113125832.png]]
-----
- CURSOR) @docker-compose.yaml => ERROR [common-service internal] load metadata for docker.io/library/openjdk:21-slim 이런 에러가 났는데, openjdk:21-slim 이것이 도커 허브에 없어. 그래서 모든 Dockerfile 과 컨테이너 버전을 openjdk:17-slim 으로 변경해줘.
	- 프로젝트를 aws에 배포하려고 해. 그런데 추후 쿠버네티스에서 배포할 건데, 지금은 도커컴포즈로 하는 중이야. => ERROR [common-service internal] load metadata for docker.io/library/openjdk:21-slim 빌드중에 openjdk가 버전 이슈가 있어. 라이센스가 무료인 jdk 중에서 가장 최신인 것을 추천해줘
		- 이클립스 사용?



@docker-compose.yaml => ERROR [common-service internal] load metadata for docker.io/library/openjdk:21-slim 이런 에러가 났는데, openjdk:21-slim 이것이 도커 허브에 없어. 그래서 모든 Dockerfile 과 컨테이너 버전을 eclipse-temurin:21-jdk-ubi9-minimal 으로 변경해줘.

@Dockerfile 여기에 eclipse-temurin:21-jdk-alpine로 이미지를 변경해서 작업하고, 도커 컴포즈까지 적용해줘

eclipse-temurin:21-jdk-alpine


![[Pasted image 20251113172521.png]]

- 야물은 렝기쥐 서비스
- 도커는 라이브