- 커서로 열어서 pnpm 이 되는지 모르는 상태면 npm 인스톨부터 하기 /npm run dev


- ouath 를 더 자세히 알아보자
	- protocal란 무엇인가? 규칙, 규약이다. (리액트에서 promise랑은 다른 것임)
		- 혼자 서버에 지키는 건 프라미스
		- 회사 간 지키는 건 프로토콜
		- 법은 안지키면 에러, 약속은 아무 페널티 없음. 규약은 약속에 가깝지만 페널티가 없긴 하나 무반응에 가까운거지 빨간 에러를 내진 않음. 프로토콜을 안 지키면 작동은 안하게 됨
		- auth 는 인증만 의미하고, 인가는 우리가 사람이 해야함
		- 앞에 O가 붙는것은 open을 의미해. 카카오/네이버/구글처럼
		- 인증시스템은 규약으로 똑같고 인가는 회사마다 다른거지
	- 명칭
		- 개발자 - 클라이언트 -오너
			- 오너는 개인정보를 소유하는 자를 뜻함
			- 클라이언트 = 서버라고 부름

- 디자인패턴의 꽃은 전략 / 자바스크립트의 꽃은 클로저임

- EDD: Event Driven Development 는 특정 이벤트(Event)가 발생했을 때 동작이 수행되는 개발 방식이다. 이벤트 주도 개발.
- 속성과 기능을 분리하려고 app 밑에있는 폴더링 구조와 동일하게 가

-  프론트 수정
	- 아래 사진처럼 루트에 서비스폴더 만들고, 아래에 대시보드 폴더만들고, mainservice.ts  파일 만들어
	- 아래 사진처럼 프롬프트를 쳐서 내용바꿔. (클로저를 하기위한 단계임)
	- app 폴더 밑에 (홈)page.tsx에서 속성(<리턴>밑)부분과 과 기능(그 위 부분)을 분리하는 것. 주의할 점은 기능부분에서 use~ 인 훅은 냅둬야 함. 컴포넌트 안?밖? 있으면 돼? 안돼?
	![[Pasted image 20251128105759.png]]
	- 화살표함수 다 따로있는 거 하나로 묶어주기 = 자바스크립트의 꽃인 클로저 방식임
		- 클로저로 묶으면 TS 안에 함수를 이너함수, TS 밖에 있지만 클로저로 감싸진 함수를 아우터함수라고 함
		- CURSOR) @page.tsx(app 밑)여기에서 @page.tsx (9-92) 이 헨들러를 @mainservice.ts 여기로 리팩토링하는데, import는 너가 자동으로 연결해줘.
		- CURSOR) @mainservice.ts 여기에 있는 헨들러들을 클로저로 구조를 변경해서 이너함수로 변경해줘
		- 위 사진에서 아래사진으로 바뀐거임
			![[Pasted image 20251128111634.png]]![[Pasted image 20251128112735.png]]
	- 람다로 묶어버린 이유는 람다함수로 세개를 묶어버리면 메모리 사용을 통제할 수 있어서(최소화)임. 이런걸 일급객체로 만들었다고 생각하면 돼
	- 람다 형태로 클로저를 만든 것.
	- 안에 이너함수로 있는 애들을 람다라고 부르지 않는 이유는 
	- 텀블러가 일반함수, 일회용컵이 람다
	- 람다는 메모리를 잡아먹지 않지만 재사용이 안돼. 
	- 다 람다로 해버리면 연산을 계속 더 해야되니깐 안좋아.
	- 부모가 람다이면 자식은 일반함수로 하는 프렉탈 구조로 가.
	- iife 패던 : ()=>()()에서  ( ) ( ) 가 두개인 이유
		- 정의 되자마자 즉시 실행(호출)되는 함수 표현식


- 일반함수는 즉시호출이 아님. 람다는 즉시호출 아님. 콜백은 즉시가 아님. 즉시는 버튼 안 눌렀는데 작동하는 것.
- 즉시 = 상시대기 = iife로  이파이 패턴 
- 즉시실행이라하면 버튼 눌르면 빨리온다고 오해하게 되니까. 
- 모니터링

- 내가 tsx를 만들고 있으면 일반함수로 하는 게 좋아. 두꺼워지는 책은 싫지만 전기 없어도 돌아가. 메모리를 많이 잡아먹는거지. 대신 책은 바로 필 수 있어 (화면은 이걸로 짜야 해)
- 이 북은 내가 보는 화면만 존재하니까 람다야. 많은 양을 넣을 수 있지만 전기 있어야 해. 메모리 불러와야하니까 시간이 좀 걸려.


- 윈도우와 로케이션
- 현재 브라우저의 위치를 바꿔라 
- 






