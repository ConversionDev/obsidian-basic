
- 디자인패턴은 가짜가 많으니까 gof design pattern free pdf 로 검색해서 영어버전으로 다운받아
	![[Pasted image 20251105101356.png]]
- { } 로 묶은 게 노테이션, 추가설명이 어노테이션
- 어제 패턴 배운거는 빌더랑 템플릿(=오버라이드)
	- **Builder Pattern (빌더 패턴)**|객체 생성 과정을 단계별로 분리, `new` 없이 깔끔하게 객체 생성|`User.builder().name("홍길동").build()`
	- **Template Pattern (템플릿 패턴)**|공통 구조를 만들어두고 **세부 로직만 오버라이드(override)** 하여 재사용|`abstract class` + `@Override` 사용|

- JPA 책 p.164 엔티티들은 = 엔티티가 여러개다. (이거는 사람이 해야 돼)
	- 자바 커서에 있는 Entity는 진짜 Entity가 아니라 Entitiy를 지키는 "놈"이야.
	- 그래서 커서에서 Entity는 객체냐 개체냐 따질 수 없어서 이름에서 Entity를 빼줘
	- 따라서 진짜 Entity는 테이블이다
		- 9~11번이 기능, 밑에가 속성 = 객체는 맞아
		- 10번: 테이블을 만들라는 기능
		- 11번: 그 테이블의 이름이 players 라고 하는 기능![[Pasted image 20251105104041.png]]
	- VO 도 지워. DTO가 VO 역할을 할거야 (나중에 MODEL로 바뀐대)
	- 자바에서는 매핑 = 리액트에서는 바인딩
		- 그래서 리액트에서 단방향 바인딩과 양방향 바인딩이라고 함
	- 스칼라는 방향성 없음. 벡터는 방향성 있음
	- 람다 = 스칼라. 벡터가 빨라 스칼라가 빨라? 스칼ㄹ. 그럼 벡터를 스칼라로 바꾸려면? 디렉션(방향성)을 삭제해.
	- 파이프라인은 양방향이 안돼. 테이블끼리 연결하는 게 연관관계이고 이것은 양방향과 단방향 모두 가능
	- 서비스가 컨트롤러의 부모, 서비스가 레파지토리의 인스턴스를 갖고 있으니 레파지토리가 부모, 엔티티가 레파지토리의 부모
	- 단방향: 테이블 간의 owner를 정하는 것
			A -> B
	- 양방향: 단방향을 두 개 만들어. 교차엔티티(크로스 엔티티)가 가운데 생기는 것. C는 A와 B의 자식
			A <- C -> B
	- 순수한 객체란 어노테이션이 없는 것을 의미함
- 

- JPA에서 크로스 엔티티는 GOF 디자인 패턴에서 어떤것과 가까운가?
	- 중재자 패턴
		![[Pasted image 20251105115434.png]]

- GPT) 조인에서  fk로 사용할 수 있는 것이 pk 말고 또 뭐 있어?
	- UNIQUE
	- 기존에 있던 주민번호를 유니크키로 뺀다. 유니크키는 널 허용 함